/**
 * Generate real Prover.toml test data for ZK Teen Patti circuits.
 * 
 * Uses @aztec/bb.js v0.84.0 Barretenberg to compute pedersen hashes
 * that match the Noir circuit's `std::hash::pedersen_hash`.
 * 
 * Outputs:
 *   - shuffle/Prover.toml  (real UIDs)
 *   - deal/Prover.toml     (real Merkle tree data)
 *   - show/Prover.toml     (real hand reveal data)
 */

import { Barretenberg, Fr } from '@aztec/bb.js';
import { writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const CIRCUITS_DIR = join(__dirname, '..');

// Domain separation tags (must match circuits/lib/src/constants.nr)
const DOMAIN_CARD_UID = 1n;
const DOMAIN_CARD_COMMITMENT = 2n;

// Card constants
const RANK_TWO = 2;
const RANK_ACE = 14;
const SUIT_HEARTS = 0;
const SUIT_DIAMONDS = 1;
const SUIT_CLUBS = 2;
const SUIT_SPADES = 3;

const DECK_SIZE = 52;
const MERKLE_DEPTH = 6; // 2^6 = 64 leaves
const HAND_SIZE = 3;

async function main() {
  console.log('Initializing Barretenberg...');
  const api = await Barretenberg.new({ threads: 1 });
  console.log('Barretenberg initialized.');

  // ========= Compute pedersen_hash matching Noir's std::hash::pedersen_hash =========
  // In Noir: pedersen_hash([a, b, c]) 
  // In bb.js: api.pedersenHash([Fr.fromBuffer(a), Fr.fromBuffer(b), ...], 0)
  // The second param (0) is the hash index / generator offset

  async function pedersenHash(inputs) {
    const frInputs = inputs.map(v => new Fr(v));
    const result = await api.pedersenHash(frInputs, 0);
    return result;
  }

  // Helper: Convert Fr to BigInt safely (handles 0x prefix)
  function frToBigInt(fr) {
    const s = fr.toString();
    if (s.startsWith('0x')) return BigInt(s);
    return BigInt('0x' + s);
  }

  // Helper: Convert Fr to hex string with 0x prefix
  function frToHex(fr) {
    const s = fr.toString();
    if (s.startsWith('0x')) return s;
    return '0x' + s;
  }

  // ========= Generate Card UIDs =========
  console.log('\n--- Computing Card UIDs ---');
  const cardUIDs = [];
  const cardInfo = [];

  for (let suit = SUIT_HEARTS; suit <= SUIT_SPADES; suit++) {
    for (let rank = RANK_TWO; rank <= RANK_ACE; rank++) {
      const uid = await pedersenHash([DOMAIN_CARD_UID, BigInt(rank), BigInt(suit)]);
      cardUIDs.push(uid);
      cardInfo.push({ rank, suit, uid });
    }
  }

  console.log(`Computed ${cardUIDs.length} card UIDs`);
  console.log(`First UID (2 of Hearts): ${frToHex(cardUIDs[0])}`);
  console.log(`Last UID (Ace of Spades): ${frToHex(cardUIDs[51])}`);

  // ========= Shuffle: simple rotation for test =========
  console.log('\n--- Generating Shuffle Test Data ---');
  const shuffledUIDs = [...cardUIDs];
  // Fisher-Yates-like deterministic shuffle (rotate by 7 for reproducibility)
  const offset = 7;
  const rotated = [];
  for (let i = 0; i < DECK_SIZE; i++) {
    rotated.push(shuffledUIDs[(i + offset) % DECK_SIZE]);
  }

  let shuffleToml = `# Shuffle Prover.toml - Real pedersen hash UIDs\n`;
  shuffleToml += `# Generated by generate_test_data.mjs\n`;
  shuffleToml += `# Rotation by ${offset} positions\n\n`;
  shuffleToml += `uids_in = [\n`;
  for (let i = 0; i < DECK_SIZE; i++) {
    const comma = i < DECK_SIZE - 1 ? ',' : '';
    shuffleToml += `    "${frToHex(cardUIDs[i])}"${comma}\n`;
  }
  shuffleToml += `]\n\n`;
  shuffleToml += `uids_out = [\n`;
  for (let i = 0; i < DECK_SIZE; i++) {
    const comma = i < DECK_SIZE - 1 ? ',' : '';
    shuffleToml += `    "${frToHex(rotated[i])}"${comma}\n`;
  }
  shuffleToml += `]\n`;

  writeFileSync(join(CIRCUITS_DIR, 'shuffle', 'Prover.toml'), shuffleToml);
  console.log('Wrote shuffle/Prover.toml');

  // ========= Build Merkle Tree =========
  console.log('\n--- Building Merkle Tree ---');

  // Generate deterministic nonces for test (in production, use crypto random)
  const nonces = [];
  for (let i = 0; i < DECK_SIZE; i++) {
    // Simple deterministic nonce: hash of index
    const nonce = await pedersenHash([BigInt(1000 + i)]);
    nonces.push(nonce);
  }
  console.log(`Generated ${nonces.length} nonces`);

  // Compute commitments: pedersen_hash([DOMAIN_CARD_COMMITMENT, uid, nonce])
  const commitments = [];
  for (let i = 0; i < DECK_SIZE; i++) {
    const commitment = await pedersenHash([
      DOMAIN_CARD_COMMITMENT,
      frToBigInt(rotated[i]),
      frToBigInt(nonces[i]),
    ]);
    commitments.push(commitment);
  }
  console.log(`Computed ${commitments.length} commitments`);

  // Pad to 64 leaves (2^MERKLE_DEPTH)
  const numLeaves = 1 << MERKLE_DEPTH; // 64
  const leaves = [...commitments];
  while (leaves.length < numLeaves) {
    leaves.push(new Fr(0n));
  }

  // Build tree bottom-up
  const tree = [leaves]; // tree[0] = leaves
  let currentLevel = leaves;
  for (let depth = 0; depth < MERKLE_DEPTH; depth++) {
    const nextLevel = [];
    for (let i = 0; i < currentLevel.length; i += 2) {
      const left = currentLevel[i];
      const right = currentLevel[i + 1];
      const parent = await pedersenHash([
        frToBigInt(left),
        frToBigInt(right),
      ]);
      nextLevel.push(parent);
    }
    tree.push(nextLevel);
    currentLevel = nextLevel;
  }

  const merkleRoot = tree[MERKLE_DEPTH][0];
  console.log(`Merkle root: ${frToHex(merkleRoot)}`);

  // Extract Merkle proof for a given leaf index
  function getMerkleProof(leafIndex) {
    const path = [];
    const indices = [];
    let idx = leafIndex;
    for (let depth = 0; depth < MERKLE_DEPTH; depth++) {
      const isRight = idx % 2 === 1;
      const siblingIdx = isRight ? idx - 1 : idx + 1;
      path.push(tree[depth][siblingIdx]);
      indices.push(isRight ? 1 : 0); // 1 if leaf is on right side
      idx = Math.floor(idx / 2);
    }
    return { path, indices };
  }

  // ========= Deal: Player gets cards at positions 0, 1, 2 (first 3 cards from shuffled deck) =========
  console.log('\n--- Generating Deal Test Data ---');
  const dealPositions = [0, 1, 2];
  const dealCardUIDs = dealPositions.map(p => rotated[p]);
  const dealNonces = dealPositions.map(p => nonces[p]);
  const dealProofs = dealPositions.map(p => getMerkleProof(p));

  const playerId = 12345n;

  let dealToml = `# Deal Prover.toml - Real Merkle tree data\n`;
  dealToml += `# Generated by generate_test_data.mjs\n`;
  dealToml += `# Player receives cards at positions [0, 1, 2] from shuffled deck\n\n`;
  dealToml += `player_id = "0x${playerId.toString(16)}"\n`;
  dealToml += `merkle_root = "${frToHex(merkleRoot)}"\n\n`;
  dealToml += `positions = [${dealPositions.join(', ')}]\n\n`;

  dealToml += `card_uids = [\n`;
  for (let i = 0; i < HAND_SIZE; i++) {
    const comma = i < HAND_SIZE - 1 ? ',' : '';
    dealToml += `    "${frToHex(dealCardUIDs[i])}"${comma}\n`;
  }
  dealToml += `]\n\n`;

  dealToml += `nonces = [\n`;
  for (let i = 0; i < HAND_SIZE; i++) {
    const comma = i < HAND_SIZE - 1 ? ',' : '';
    dealToml += `    "${frToHex(dealNonces[i])}"${comma}\n`;
  }
  dealToml += `]\n\n`;

  // Merkle paths as array of structs
  for (let i = 0; i < HAND_SIZE; i++) {
    const proof = dealProofs[i];
    dealToml += `[[merkle_paths]]\n`;
    dealToml += `path = [\n`;
    for (let j = 0; j < MERKLE_DEPTH; j++) {
      const comma = j < MERKLE_DEPTH - 1 ? ',' : '';
      dealToml += `    "${frToHex(proof.path[j])}"${comma}\n`;
    }
    dealToml += `]\n`;
    dealToml += `indices = [${proof.indices.join(', ')}]\n\n`;
  }

  writeFileSync(join(CIRCUITS_DIR, 'deal', 'Prover.toml'), dealToml);
  console.log('Wrote deal/Prover.toml');

  // ========= Show: Reveal the 3 cards at positions 0, 1, 2 =========
  console.log('\n--- Generating Show Test Data ---');

  // Cards at positions 0, 1, 2 from the rotated deck correspond to:
  // Position 0 = original card at index 7 (offset rotation)
  // Position 1 = original card at index 8
  // Position 2 = original card at index 9
  // Card index = suit * 13 + (rank - 2)
  // Index 7 = suit=0(H), rank=9 -> 9 of Hearts
  // Index 8 = suit=0(H), rank=10 -> 10 of Hearts
  // Index 9 = suit=0(H), rank=11 -> Jack of Hearts
  const showCards = [
    { rank: 9, suit: 0 },   // 9 of Hearts
    { rank: 10, suit: 0 },  // 10 of Hearts  
    { rank: 11, suit: 0 },  // Jack of Hearts
  ];

  // Verify these cards match the UIDs
  for (let i = 0; i < HAND_SIZE; i++) {
    const expectedUID = await pedersenHash([
      DOMAIN_CARD_UID,
      BigInt(showCards[i].rank),
      BigInt(showCards[i].suit),
    ]);
    const actualUID = dealCardUIDs[i];
    const match = expectedUID.toString() === actualUID.toString();
    console.log(`Card ${i}: ${showCards[i].rank} of suit ${showCards[i].suit} -> UID match: ${match}`);
    if (!match) {
      console.error(`UID MISMATCH! Expected ${expectedUID.toString()}, got ${actualUID.toString()}`);
      // Let's figure out the actual card
      for (let s = 0; s <= 3; s++) {
        for (let r = 2; r <= 14; r++) {
          const testUID = await pedersenHash([DOMAIN_CARD_UID, BigInt(r), BigInt(s)]);
          if (testUID.toString() === actualUID.toString()) {
            console.log(`  -> Actual card: rank=${r}, suit=${s}`);
            showCards[i].rank = r;
            showCards[i].suit = s;
          }
        }
      }
    }
  }

  // Compute hand ranking (matching the circuit logic)
  const ranks = showCards.map(c => c.rank);
  const suits = showCards.map(c => c.suit);
  
  // Sort descending
  const sorted = [...ranks].sort((a, b) => b - a);
  const [high, mid, low] = sorted;

  const allSameSuit = suits[0] === suits[1] && suits[1] === suits[2];
  const isConsecutive = (high === mid + 1 && mid === low + 1) || 
                        (high === 14 && mid === 3 && low === 2);

  // A-2-3 special case values
  const isAceLow = high === 14 && mid === 3 && low === 2;
  const valueHigh = isAceLow ? 3 : high;
  const valueMid = isAceLow ? 2 : mid;
  const valueLow = isAceLow ? 1 : low;

  let handRank, handValue;
  if (high === mid && mid === low) {
    // Trail
    handRank = 6;
    handValue = BigInt(6 * 1000000 + high * 10000 + mid * 100 + low);
  } else if (allSameSuit && isConsecutive) {
    // Pure Sequence
    handRank = 5;
    handValue = BigInt(5 * 1000000 + valueHigh * 10000 + valueMid * 100 + valueLow);
  } else if (isConsecutive) {
    // Sequence
    handRank = 4;
    handValue = BigInt(4 * 1000000 + valueHigh * 10000 + valueMid * 100 + valueLow);
  } else if (allSameSuit) {
    // Color (Flush)
    handRank = 3;
    handValue = BigInt(3 * 1000000 + high * 10000 + mid * 100 + low);
  } else if (high === mid || mid === low) {
    // Pair
    let pairRank, kicker;
    if (high === mid) {
      pairRank = high;
      kicker = low;
    } else {
      pairRank = mid;
      kicker = high;
    }
    handRank = 2;
    handValue = BigInt(2 * 1000000 + pairRank * 10000 + kicker * 100);
  } else {
    // High Card
    handRank = 1;
    handValue = BigInt(1 * 1000000 + high * 10000 + mid * 100 + low);
  }

  console.log(`Hand: ranks=[${ranks}], suits=[${suits}]`);
  console.log(`Sorted: [${high}, ${mid}, ${low}]`);
  console.log(`Hand rank: ${handRank}, Hand value: ${handValue}`);

  const gameId = 42n;

  let showToml = `# Show Prover.toml - Real hand reveal data\n`;
  showToml += `# Generated by generate_test_data.mjs\n`;
  showToml += `# Cards: ${showCards.map(c => `${c.rank} of suit ${c.suit}`).join(', ')}\n`;
  showToml += `# Hand: rank=${handRank}, value=${handValue}\n\n`;

  showToml += `game_id = "${gameId}"\n`;
  showToml += `player_id = "0x${playerId.toString(16)}"\n`;
  showToml += `merkle_root = "${frToHex(merkleRoot)}"\n`;
  showToml += `card_rank_0 = ${showCards[0].rank}\n`;
  showToml += `card_rank_1 = ${showCards[1].rank}\n`;
  showToml += `card_rank_2 = ${showCards[2].rank}\n`;
  showToml += `card_suit_0 = ${showCards[0].suit}\n`;
  showToml += `card_suit_1 = ${showCards[1].suit}\n`;
  showToml += `card_suit_2 = ${showCards[2].suit}\n`;
  showToml += `hand_rank = ${handRank}\n`;
  showToml += `hand_value = "${handValue}"\n\n`;

  showToml += `card_uids = [\n`;
  for (let i = 0; i < HAND_SIZE; i++) {
    const comma = i < HAND_SIZE - 1 ? ',' : '';
    showToml += `    "${frToHex(dealCardUIDs[i])}"${comma}\n`;
  }
  showToml += `]\n\n`;

  showToml += `nonces = [\n`;
  for (let i = 0; i < HAND_SIZE; i++) {
    const comma = i < HAND_SIZE - 1 ? ',' : '';
    showToml += `    "${frToHex(dealNonces[i])}"${comma}\n`;
  }
  showToml += `]\n\n`;

  showToml += `positions = [${dealPositions.join(', ')}]\n\n`;

  for (let i = 0; i < HAND_SIZE; i++) {
    const proof = dealProofs[i];
    showToml += `[[merkle_paths]]\n`;
    showToml += `path = [\n`;
    for (let j = 0; j < MERKLE_DEPTH; j++) {
      const comma = j < MERKLE_DEPTH - 1 ? ',' : '';
      showToml += `    "${frToHex(proof.path[j])}"${comma}\n`;
    }
    showToml += `]\n`;
    showToml += `indices = [${proof.indices.join(', ')}]\n\n`;
  }

  writeFileSync(join(CIRCUITS_DIR, 'show', 'Prover.toml'), showToml);
  console.log('Wrote show/Prover.toml');

  // ========= Summary =========
  console.log('\n========= SUMMARY =========');
  console.log(`Cards generated: ${cardUIDs.length}`);
  console.log(`Merkle root: ${frToHex(merkleRoot)}`);
  console.log(`Shuffle: rotation by ${offset} (52 real UIDs)`);
  console.log(`Deal: positions [${dealPositions}], player_id=0x${playerId.toString(16)}`);
  console.log(`Show: cards=[${showCards.map(c => `${c.rank}s${c.suit}`).join(',')}], rank=${handRank}, value=${handValue}`);
  console.log('===========================\n');

  await api.destroy();
  console.log('Done!');
}

main().catch(e => {
  console.error('Error:', e);
  process.exit(1);
});
