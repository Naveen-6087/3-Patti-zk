{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"201806871499455253","abi":{"parameters":[{"name":"game_id","type":{"kind":"field"},"visibility":"public"},{"name":"player_id","type":{"kind":"field"},"visibility":"public"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"card_rank_0","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"card_rank_1","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"card_rank_2","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"card_suit_0","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"card_suit_1","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"card_suit_2","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"hand_rank","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"hand_value","type":{"kind":"field"},"visibility":"public"},{"name":"card_uids","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"nonces","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_paths","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"zk_teen_patti::types::MerkleProof","fields":[{"name":"path","type":{"kind":"array","length":6,"type":{"kind":"field"}}},{"name":"indices","type":{"kind":"array","length":6,"type":{"kind":"integer","sign":"unsigned","width":1}}}]}},"visibility":"private"},{"name":"positions","type":{"kind":"array","length":3,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"}],"return_type":null,"error_types":{"1657225594719303592":{"error_kind":"string","string":"Invalid Merkle proof: root mismatch"},"1803097578160201588":{"error_kind":"string","string":"Hand value mismatch"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5985797412443528821":{"error_kind":"string","string":"Position out of range (must be < 52)"},"7523195261164158001":{"error_kind":"string","string":"Card UID does not match revealed rank/suit"},"10908087124093645364":{"error_kind":"string","string":"Duplicate position found"},"11028644390335697778":{"error_kind":"string","string":"Rank must be >= 2"},"14311503148548840293":{"error_kind":"string","string":"Hand rank mismatch"},"15075272709620057359":{"error_kind":"string","string":"Rank must be <= 14"},"16001389933259826523":{"error_kind":"string","string":"Suit must be <= 3"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"// Show (Showdown) Verification Circuit for ZK Teen Patti\r\n// Proves that a player's revealed cards are the ones originally dealt\r\n// AND that their hand ranking is correctly computed\r\n//\r\n// During showdown, cards ARE revealed. The ZK proof guarantees:\r\n// 1. The revealed cards match the original deal (via Merkle tree)\r\n// 2. The hand ranking is correctly evaluated (no cheating on hand strength)\r\n//\r\n// Public inputs: 10 total (well within zkVerify's 32 limit)\r\n//   - game_id, player_id, merkle_root\r\n//   - card_ranks[3], card_suits[3]\r\n//   - hand_rank, hand_value\r\n//\r\n// Private inputs:\r\n//   - card_uids[3], nonces[3], merkle_paths[3], positions[3]\r\n\r\nuse dep::zk_teen_patti::types::MerkleProof;\r\nuse dep::zk_teen_patti::card_uids::get_card_uid;\r\nuse dep::zk_teen_patti::encoding::commit_card;\r\nuse dep::zk_teen_patti::merkle::assert_merkle_proof;\r\nuse dep::zk_teen_patti::validation::{assert_unique_positions, assert_valid_position, assert_valid_card_inputs};\r\nuse dep::zk_teen_patti::hand_ranking::evaluate_hand;\r\n\r\nfn main(\r\n    // ========== Public inputs (10 total) ==========\r\n    game_id: pub Field,\r\n    player_id: pub Field,\r\n    merkle_root: pub Field,\r\n\r\n    // Revealed card details (public during showdown)\r\n    card_rank_0: pub u8,\r\n    card_rank_1: pub u8,\r\n    card_rank_2: pub u8,\r\n    card_suit_0: pub u8,\r\n    card_suit_1: pub u8,\r\n    card_suit_2: pub u8,\r\n\r\n    // Verified hand evaluation results\r\n    hand_rank: pub u8,\r\n    hand_value: pub Field,\r\n\r\n    // ========== Private witnesses ==========\r\n    card_uids: [Field; 3],           // Card unique identifiers\r\n    nonces: [Field; 3],              // Random nonces for commitments\r\n    merkle_paths: [MerkleProof; 3],  // Merkle inclusion proofs\r\n    positions: [u32; 3],             // Deck positions\r\n) {\r\n    // Pack card details into arrays for hand evaluation\r\n    let card_ranks: [u8; 3] = [card_rank_0, card_rank_1, card_rank_2];\r\n    let card_suits: [u8; 3] = [card_suit_0, card_suit_1, card_suit_2];\r\n\r\n    // 1. Validate card inputs are in range\r\n    for i in 0..3 {\r\n        assert_valid_card_inputs(card_ranks[i], card_suits[i]);\r\n    }\r\n\r\n    // 2. Verify positions are unique and in range\r\n    assert_unique_positions(positions);\r\n    for i in 0..3 {\r\n        assert_valid_position(positions[i]);\r\n    }\r\n\r\n    // 3. Verify card UIDs match the revealed (rank, suit) pairs\r\n    //    This ensures the player can't claim different cards than they hold\r\n    for i in 0..3 {\r\n        let expected_uid = get_card_uid(card_ranks[i], card_suits[i]);\r\n        assert(card_uids[i] == expected_uid, \"Card UID does not match revealed rank/suit\");\r\n    }\r\n\r\n    // 4. Verify each card commitment is in the Merkle tree\r\n    //    This proves the cards were part of the original deal\r\n    for i in 0..3 {\r\n        let commitment = commit_card(card_uids[i], nonces[i]);\r\n        assert_merkle_proof(commitment, merkle_paths[i], merkle_root);\r\n    }\r\n\r\n    // 5. Evaluate the hand and verify the claimed ranking is correct\r\n    let (computed_rank, computed_value) = evaluate_hand(card_ranks, card_suits);\r\n    assert(computed_rank == hand_rank, \"Hand rank mismatch\");\r\n    assert(computed_value == hand_value, \"Hand value mismatch\");\r\n\r\n    // game_id and player_id are public inputs for context binding\r\n    let _ = game_id;\r\n    let _ = player_id;\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/unogame/teen-patti/3-Patti-zk/circuits/show/src/main.nr"},"51":{"source":"// Precomputed card unique identifiers for a standard 52-card deck\r\n// Each UID = pedersen_hash([DOMAIN_CARD_UID, rank, suit])\r\n//\r\n// Cards are indexed as: index = (rank - 2) * 4 + suit\r\n//   rank: 2-14 (2,3,...,10,J=11,Q=12,K=13,A=14)\r\n//   suit: 0=Hearts, 1=Diamonds, 2=Clubs, 3=Spades\r\n//\r\n// IMPORTANT: These values MUST be precomputed by running the hash function\r\n// with the actual Noir pedersen_hash implementation and then hardcoded here.\r\n// Until precomputation is done, we use a runtime computation approach.\r\n//\r\n// The precomputation step:\r\n// 1. Compile this lib with the runtime fallback\r\n// 2. Run a test that prints all 52 UIDs\r\n// 3. Replace the runtime function with the hardcoded lookup table\r\n//\r\n// For now, we use runtime computation which is correct but slightly\r\n// less efficient than a lookup table. With only 52 cards and 3 per hand,\r\n// the constraint overhead is minimal.\r\n\r\nuse crate::hash::hash_card_uid;\r\nuse crate::constants::{RANK_TWO, RANK_ACE, SUIT_SPADES};\r\n\r\n/// Get the unique identifier for a card given its rank and suit\r\n/// rank: 2-14 (2=Two, ..., 14=Ace)\r\n/// suit: 0-3 (Hearts, Diamonds, Clubs, Spades)\r\n///\r\n/// Returns: pedersen_hash([DOMAIN_CARD_UID, rank, suit])\r\npub fn get_card_uid(rank: u8, suit: u8) -> Field {\r\n    // Validate inputs\r\n    assert(rank >= RANK_TWO, \"Rank must be >= 2\");\r\n    assert(rank <= RANK_ACE, \"Rank must be <= 14\");\r\n    assert(suit <= SUIT_SPADES, \"Suit must be <= 3\");\r\n\r\n    // Compute UID using pedersen hash with domain separation\r\n    hash_card_uid(rank, suit)\r\n}\r\n\r\n/// Get the deck index for a card (0-51)\r\n/// index = (rank - 2) * 4 + suit\r\npub fn get_card_index(rank: u8, suit: u8) -> u32 {\r\n    ((rank - RANK_TWO) as u32) * 4 + (suit as u32)\r\n}\r\n\r\n/// Generate all 52 card UIDs in canonical order\r\n/// Order: 2H, 2D, 2C, 2S, 3H, 3D, 3C, 3S, ..., AH, AD, AC, AS\r\npub fn generate_canonical_deck() -> [Field; 52] {\r\n    let mut deck: [Field; 52] = [0; 52];\r\n\r\n    for rank_offset in 0..13 {\r\n        let rank = (rank_offset + 2) as u8; // 2 through 14\r\n        for suit in 0..4 {\r\n            let idx = rank_offset * 4 + suit;\r\n            deck[idx] = get_card_uid(rank, suit as u8);\r\n        }\r\n    }\r\n\r\n    deck\r\n}\r\n\r\n// ============================================================\r\n// Tests\r\n// ============================================================\r\n\r\n#[test]\r\nfn test_card_uid_deterministic() {\r\n    let uid1 = get_card_uid(14, 0); // Ace of Hearts\r\n    let uid2 = get_card_uid(14, 0); // Same card\r\n    assert(uid1 == uid2, \"Same card should produce same UID\");\r\n}\r\n\r\n#[test]\r\nfn test_card_uid_unique() {\r\n    let ace_hearts = get_card_uid(14, 0);\r\n    let ace_diamonds = get_card_uid(14, 1);\r\n    let king_hearts = get_card_uid(13, 0);\r\n    assert(ace_hearts != ace_diamonds, \"Different suits should have different UIDs\");\r\n    assert(ace_hearts != king_hearts, \"Different ranks should have different UIDs\");\r\n}\r\n\r\n#[test]\r\nfn test_card_index() {\r\n    assert(get_card_index(2, 0) == 0, \"2H should be index 0\");\r\n    assert(get_card_index(2, 3) == 3, \"2S should be index 3\");\r\n    assert(get_card_index(3, 0) == 4, \"3H should be index 4\");\r\n    assert(get_card_index(14, 3) == 51, \"AS should be index 51\");\r\n}\r\n\r\n#[test]\r\nfn test_canonical_deck_size() {\r\n    let deck = generate_canonical_deck();\r\n    // Verify all elements are non-zero (valid hashes)\r\n    for i in 0..52 {\r\n        assert(deck[i] != 0, \"Deck UID should not be zero\");\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_canonical_deck_unique() {\r\n    let deck = generate_canonical_deck();\r\n    // Verify all UIDs are unique\r\n    for i in 0..52 {\r\n        for j in (i + 1)..52 {\r\n            assert(deck[i] != deck[j], \"All deck UIDs should be unique\");\r\n        }\r\n    }\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/unogame/teen-patti/3-Patti-zk/circuits/lib/src/card_uids.nr"},"53":{"source":"// Card encoding utilities for ZK Teen Patti\r\n\r\nuse crate::hash::hash_card_commitment;\r\nuse crate::card_uids::get_card_uid;\r\nuse crate::constants::{RANK_TWO, RANK_ACE, SUIT_SPADES};\r\n\r\n/// Verify that a card UID matches the expected rank and suit\r\n/// Computes the UID from (rank, suit) and asserts it equals the provided uid\r\npub fn verify_card_uid(rank: u8, suit: u8, expected_uid: Field) {\r\n    let computed_uid = get_card_uid(rank, suit);\r\n    assert(computed_uid == expected_uid, \"Card UID mismatch\");\r\n}\r\n\r\n/// Create a card commitment (Merkle tree leaf)\r\n/// commitment = pedersen_hash([DOMAIN_CARD_COMMITMENT, card_uid, nonce])\r\npub fn commit_card(card_uid: Field, nonce: Field) -> Field {\r\n    hash_card_commitment(card_uid, nonce)\r\n}\r\n\r\n/// Validate that rank and suit values are in valid ranges\r\npub fn assert_valid_card(rank: u8, suit: u8) {\r\n    assert(rank >= RANK_TWO, \"Rank must be >= 2\");\r\n    assert(rank <= RANK_ACE, \"Rank must be <= 14 (Ace)\");\r\n    assert(suit <= SUIT_SPADES, \"Suit must be <= 3\");\r\n}\r\n\r\n// ============================================================\r\n// Tests\r\n// ============================================================\r\n\r\n#[test]\r\nfn test_commit_card() {\r\n    let uid = get_card_uid(14, 0); // Ace of Hearts\r\n    let nonce: Field = 12345;\r\n    let c1 = commit_card(uid, nonce);\r\n    let c2 = commit_card(uid, nonce);\r\n    assert(c1 == c2, \"Same inputs should produce same commitment\");\r\n}\r\n\r\n#[test]\r\nfn test_commit_different_nonces() {\r\n    let uid = get_card_uid(14, 0);\r\n    let c1 = commit_card(uid, 111);\r\n    let c2 = commit_card(uid, 222);\r\n    assert(c1 != c2, \"Different nonces should produce different commitments\");\r\n}\r\n\r\n#[test]\r\nfn test_verify_card_uid() {\r\n    let uid = get_card_uid(10, 2); // Ten of Clubs\r\n    verify_card_uid(10, 2, uid);   // Should not panic\r\n}\r\n\r\n#[test]\r\nfn test_assert_valid_card() {\r\n    assert_valid_card(2, 0);   // 2 of Hearts\r\n    assert_valid_card(14, 3);  // Ace of Spades\r\n    assert_valid_card(10, 2);  // Ten of Clubs\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/unogame/teen-patti/3-Patti-zk/circuits/lib/src/encoding.nr"},"54":{"source":"// Hand ranking module for ZK Teen Patti\r\n// Evaluates a 3-card hand and determines its rank and comparison value\r\n//\r\n// Hand rankings (highest to lowest):\r\n// 6 = Trail (Three of a Kind) - e.g., AAA\r\n// 5 = Pure Sequence (Straight Flush) - consecutive same suit\r\n// 4 = Sequence (Straight/Run) - consecutive different suits\r\n// 3 = Color (Flush) - same suit, not consecutive\r\n// 2 = Pair (Two of a Kind) - two matching ranks\r\n// 1 = High Card - none of the above\r\n//\r\n// Special case: A-2-3 is the LOWEST sequence (not the highest)\r\n\r\nuse crate::types::{\r\n    HAND_TRAIL, HAND_PURE_SEQUENCE, HAND_SEQUENCE,\r\n    HAND_COLOR, HAND_PAIR, HAND_HIGH_CARD,\r\n};\r\n\r\n/// Sort 3 ranks in descending order (highest first)\r\n/// Simple 3-element sort using comparisons\r\n/// Returns (high, mid, low)\r\nfn sort_three_desc(a: u8, b: u8, c: u8) -> (u8, u8, u8) {\r\n    let mut h = a;\r\n    let mut m = b;\r\n    let mut l = c;\r\n\r\n    // Bubble sort for 3 elements (3 comparisons)\r\n    if m > h {\r\n        let tmp = h;\r\n        h = m;\r\n        m = tmp;\r\n    }\r\n    if l > m {\r\n        let tmp = m;\r\n        m = l;\r\n        l = tmp;\r\n    }\r\n    if m > h {\r\n        let tmp = h;\r\n        h = m;\r\n        m = tmp;\r\n    }\r\n\r\n    (h, m, l)\r\n}\r\n\r\n/// Check if three ranks form a consecutive sequence\r\n/// Returns true if the ranks are consecutive (after sorting)\r\n/// Special case: A(14)-2-3 is treated as a sequence (lowest)\r\nfn is_consecutive(high: u8, mid: u8, low: u8) -> bool {\r\n    // Normal case: h = m+1 = l+2\r\n    let normal = (high == mid + 1) & (mid == low + 1);\r\n\r\n    // Special case: A-2-3 -> sorted as (14, 3, 2)\r\n    let ace_low = (high == 14) & (mid == 3) & (low == 2);\r\n\r\n    normal | ace_low\r\n}\r\n\r\n/// Check if all three suits are the same\r\nfn is_same_suit(s0: u8, s1: u8, s2: u8) -> bool {\r\n    (s0 == s1) & (s1 == s2)\r\n}\r\n\r\n/// Evaluate a 3-card hand\r\n///\r\n/// Parameters:\r\n/// - ranks: array of 3 card ranks (2-14)\r\n/// - suits: array of 3 card suits (0-3)\r\n///\r\n/// Returns: (hand_rank, hand_value)\r\n/// - hand_rank: 1-6 (HIGH_CARD to TRAIL)\r\n/// - hand_value: encoded comparison value for tiebreaking\r\n///   Format: hand_rank * 1_000_000 + high * 10_000 + mid * 100 + low\r\n///   For A-2-3 sequence: uses 3 as high (lowest sequence)\r\n///   For pairs: pair_rank * 10_000 + kicker * 100\r\npub fn evaluate_hand(ranks: [u8; 3], suits: [u8; 3]) -> (u8, Field) {\r\n    // Sort ranks descending\r\n    let (high, mid, low) = sort_three_desc(ranks[0], ranks[1], ranks[2]);\r\n\r\n    let same_suit = is_same_suit(suits[0], suits[1], suits[2]);\r\n    let consecutive = is_consecutive(high, mid, low);\r\n\r\n    // Determine hand rank\r\n    let is_trail = (high == mid) & (mid == low);\r\n\r\n    // For value encoding, handle A-2-3 special case\r\n    // A-2-3 sorted = (14, 3, 2), but its sequence value should be lowest\r\n    let is_ace_low = (high == 14) & (mid == 3) & (low == 2);\r\n\r\n    // Determine pair\r\n    let pair_high = (high == mid) & (mid != low);   // Pair of high + kicker\r\n    let pair_low = (high != mid) & (mid == low);     // Pair of low + kicker\r\n    let is_pair = pair_high | pair_low;\r\n\r\n    // Assign hand rank (check in order of priority)\r\n    let mut hand_rank: u8 = HAND_HIGH_CARD;\r\n    let mut value_high: u8 = high;\r\n    let mut value_mid: u8 = mid;\r\n    let mut value_low: u8 = low;\r\n\r\n    if is_trail {\r\n        hand_rank = HAND_TRAIL;\r\n        // value = rank of the trail (all three same)\r\n        // high = mid = low, so just use high\r\n    } else if consecutive & same_suit {\r\n        hand_rank = HAND_PURE_SEQUENCE;\r\n        if is_ace_low {\r\n            // A-2-3 pure sequence: lowest pure sequence\r\n            value_high = 3;\r\n            value_mid = 2;\r\n            value_low = 1; // Ace counts as 1 in A-2-3\r\n        }\r\n    } else if consecutive {\r\n        hand_rank = HAND_SEQUENCE;\r\n        if is_ace_low {\r\n            value_high = 3;\r\n            value_mid = 2;\r\n            value_low = 1;\r\n        }\r\n    } else if same_suit {\r\n        hand_rank = HAND_COLOR;\r\n        // Values stay as sorted high/mid/low\r\n    } else if is_pair {\r\n        hand_rank = HAND_PAIR;\r\n        if pair_high {\r\n            // Pair is high+mid, kicker is low\r\n            value_high = high; // pair rank\r\n            value_mid = low;   // kicker\r\n            value_low = 0;\r\n        } else {\r\n            // Pair is mid+low, kicker is high\r\n            value_high = mid;  // pair rank\r\n            value_mid = high;  // kicker\r\n            value_low = 0;\r\n        }\r\n    }\r\n    // else: HIGH_CARD, values already sorted\r\n\r\n    // Encode hand value for comparison\r\n    // hand_rank * 1_000_000 + value_high * 10_000 + value_mid * 100 + value_low\r\n    let hand_value: Field = (hand_rank as Field) * 1000000\r\n        + (value_high as Field) * 10000\r\n        + (value_mid as Field) * 100\r\n        + (value_low as Field);\r\n\r\n    (hand_rank, hand_value)\r\n}\r\n\r\n/// Compare two hands: returns true if hand_a is strictly better than hand_b\r\npub fn is_hand_better(hand_value_a: Field, hand_value_b: Field) -> bool {\r\n    // Since hand_value encoding preserves ordering, direct comparison works\r\n    // But Field comparison is tricky in Noir - we need to cast or use a different approach\r\n    // For circuit use, we expose hand_value as a public input and compare off-chain\r\n    // In-circuit, we just verify the evaluation is correct\r\n    hand_value_a != hand_value_b // placeholder - actual comparison done off-chain\r\n}\r\n\r\n// ============================================================\r\n// Tests\r\n// ============================================================\r\n\r\n#[test]\r\nfn test_sort_three_desc() {\r\n    let (h, m, l) = sort_three_desc(5, 10, 3);\r\n    assert(h == 10, \"High should be 10\");\r\n    assert(m == 5, \"Mid should be 5\");\r\n    assert(l == 3, \"Low should be 3\");\r\n}\r\n\r\n#[test]\r\nfn test_sort_already_sorted() {\r\n    let (h, m, l) = sort_three_desc(14, 10, 5);\r\n    assert(h == 14, \"High should be 14\");\r\n    assert(m == 10, \"Mid should be 10\");\r\n    assert(l == 5, \"Low should be 5\");\r\n}\r\n\r\n#[test]\r\nfn test_trail_aces() {\r\n    let (rank, value) = evaluate_hand([14, 14, 14], [0, 1, 2]);\r\n    assert(rank == HAND_TRAIL, \"Should be Trail\");\r\n    // Value = 6 * 1_000_000 + 14 * 10_000 + 14 * 100 + 14 = 6_141_414\r\n    assert(value == 6141414, \"Trail of Aces value\");\r\n}\r\n\r\n#[test]\r\nfn test_trail_twos() {\r\n    let (rank, value) = evaluate_hand([2, 2, 2], [0, 1, 3]);\r\n    assert(rank == HAND_TRAIL, \"Should be Trail\");\r\n    // Value = 6 * 1_000_000 + 2 * 10_000 + 2 * 100 + 2 = 6_020_202\r\n    assert(value == 6020202, \"Trail of Twos value\");\r\n}\r\n\r\n#[test]\r\nfn test_pure_sequence_akq() {\r\n    // A-K-Q of Hearts (same suit)\r\n    let (rank, value) = evaluate_hand([14, 13, 12], [0, 0, 0]);\r\n    assert(rank == HAND_PURE_SEQUENCE, \"Should be Pure Sequence\");\r\n    // Value = 5 * 1_000_000 + 14 * 10_000 + 13 * 100 + 12 = 5_141_312\r\n    assert(value == 5141312, \"Pure Sequence A-K-Q value\");\r\n}\r\n\r\n#[test]\r\nfn test_pure_sequence_a23() {\r\n    // A-2-3 of Diamonds (lowest pure sequence)\r\n    let (rank, value) = evaluate_hand([14, 2, 3], [1, 1, 1]);\r\n    assert(rank == HAND_PURE_SEQUENCE, \"Should be Pure Sequence\");\r\n    // A-2-3: value_high=3, value_mid=2, value_low=1\r\n    // Value = 5 * 1_000_000 + 3 * 10_000 + 2 * 100 + 1 = 5_030_201\r\n    assert(value == 5030201, \"Pure Sequence A-2-3 value\");\r\n}\r\n\r\n#[test]\r\nfn test_sequence_normal() {\r\n    // 7-8-9 different suits\r\n    let (rank, _value) = evaluate_hand([8, 7, 9], [0, 1, 2]);\r\n    assert(rank == HAND_SEQUENCE, \"Should be Sequence\");\r\n}\r\n\r\n#[test]\r\nfn test_sequence_a23() {\r\n    // A-2-3 different suits (lowest sequence)\r\n    let (rank, value) = evaluate_hand([14, 2, 3], [0, 1, 2]);\r\n    assert(rank == HAND_SEQUENCE, \"Should be Sequence\");\r\n    // Value = 4 * 1_000_000 + 3 * 10_000 + 2 * 100 + 1 = 4_030_201\r\n    assert(value == 4030201, \"Sequence A-2-3 value\");\r\n}\r\n\r\n#[test]\r\nfn test_color_flush() {\r\n    // 2-5-9 all Hearts (same suit, not consecutive)\r\n    let (rank, _value) = evaluate_hand([2, 5, 9], [0, 0, 0]);\r\n    assert(rank == HAND_COLOR, \"Should be Color/Flush\");\r\n}\r\n\r\n#[test]\r\nfn test_pair_high() {\r\n    // A-A-K\r\n    let (rank, value) = evaluate_hand([14, 14, 13], [0, 1, 2]);\r\n    assert(rank == HAND_PAIR, \"Should be Pair\");\r\n    // pair_rank=14, kicker=13\r\n    // Value = 2 * 1_000_000 + 14 * 10_000 + 13 * 100 + 0 = 2_141_300\r\n    assert(value == 2141300, \"Pair of Aces value\");\r\n}\r\n\r\n#[test]\r\nfn test_pair_low() {\r\n    // K-3-3\r\n    let (rank, value) = evaluate_hand([13, 3, 3], [0, 1, 2]);\r\n    assert(rank == HAND_PAIR, \"Should be Pair\");\r\n    // pair_rank=3, kicker=13\r\n    // Value = 2 * 1_000_000 + 3 * 10_000 + 13 * 100 + 0 = 2_031_300\r\n    assert(value == 2031300, \"Pair of 3s with K kicker\");\r\n}\r\n\r\n#[test]\r\nfn test_high_card() {\r\n    // A-K-J different suits, not consecutive\r\n    let (rank, value) = evaluate_hand([14, 13, 11], [0, 1, 2]);\r\n    assert(rank == HAND_HIGH_CARD, \"Should be High Card\");\r\n    // Value = 1 * 1_000_000 + 14 * 10_000 + 13 * 100 + 11 = 1_141_311\r\n    assert(value == 1141311, \"High Card A-K-J value\");\r\n}\r\n\r\n#[test]\r\nfn test_trail_beats_pure_sequence() {\r\n    let (_rank_trail, value_trail) = evaluate_hand([2, 2, 2], [0, 1, 2]);\r\n    let (_rank_ps, value_ps) = evaluate_hand([14, 13, 12], [0, 0, 0]);\r\n    // Trail of 2s (6_020_202) should beat Pure Sequence A-K-Q (5_141_312)\r\n    // In Field arithmetic comparison is tricky, but the encoded values preserve ordering\r\n    // 6_020_202 > 5_141_312\r\n    assert(value_trail != value_ps, \"Trail and Pure Sequence should differ\");\r\n}\r\n\r\n#[test]\r\nfn test_pure_sequence_akq_beats_a23() {\r\n    let (_rank1, value_akq) = evaluate_hand([14, 13, 12], [0, 0, 0]);\r\n    let (_rank2, value_a23) = evaluate_hand([14, 2, 3], [1, 1, 1]);\r\n    // AKQ (5_141_312) > A23 (5_030_201)\r\n    assert(value_akq != value_a23, \"AKQ should beat A23\");\r\n}\r\n\r\n#[test]\r\nfn test_high_card_lowest() {\r\n    // Lowest high card: 5-3-2 different suits\r\n    let (rank, value) = evaluate_hand([5, 3, 2], [0, 1, 2]);\r\n    assert(rank == HAND_HIGH_CARD, \"Should be High Card\");\r\n    // Value = 1 * 1_000_000 + 5 * 10_000 + 3 * 100 + 2 = 1_050_302\r\n    assert(value == 1050302, \"Lowest high card value\");\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/unogame/teen-patti/3-Patti-zk/circuits/lib/src/hand_ranking.nr"},"55":{"source":"// Hashing utilities for ZK Teen Patti\r\n// Uses std::hash::pedersen_hash - guaranteed available in Noir v1.0.0-beta.6\r\n// Pedersen hash is a black-box function backed by Barretenberg, so it is\r\n// consistent across the Noir circuit AND the bb.js/Barretenberg JS/WASM API.\r\n\r\nuse std::hash::pedersen_hash;\r\n\r\nuse crate::constants::{DOMAIN_CARD_UID, DOMAIN_CARD_COMMITMENT, DOMAIN_MOVE};\r\n\r\n/// Hash 2 field elements using Pedersen\r\npub fn hash_2(a: Field, b: Field) -> Field {\r\n    pedersen_hash([a, b])\r\n}\r\n\r\n/// Hash 3 field elements using Pedersen\r\npub fn hash_3(a: Field, b: Field, c: Field) -> Field {\r\n    pedersen_hash([a, b, c])\r\n}\r\n\r\n/// Hash 4 field elements using Pedersen\r\npub fn hash_4(a: Field, b: Field, c: Field, d: Field) -> Field {\r\n    pedersen_hash([a, b, c, d])\r\n}\r\n\r\n/// Compute a card's unique identifier\r\n/// card_uid = pedersen_hash([DOMAIN_CARD_UID, rank, suit])\r\n///\r\n/// NOTE: For performance, use the precomputed lookup table in card_uids.nr\r\n/// instead of calling this at runtime. This function is for testing/validation.\r\npub fn hash_card_uid(rank: u8, suit: u8) -> Field {\r\n    hash_3(DOMAIN_CARD_UID, rank as Field, suit as Field)\r\n}\r\n\r\n/// Create a card commitment (used as Merkle tree leaf)\r\n/// commitment = pedersen_hash([DOMAIN_CARD_COMMITMENT, card_uid, nonce])\r\npub fn hash_card_commitment(card_uid: Field, nonce: Field) -> Field {\r\n    hash_3(DOMAIN_CARD_COMMITMENT, card_uid, nonce)\r\n}\r\n\r\n/// Hash two Merkle tree children into a parent node\r\n/// Using raw pedersen_hash (no domain separation) for simplicity\r\n/// node = pedersen_hash([left, right])\r\npub fn hash_merkle_node(left: Field, right: Field) -> Field {\r\n    hash_2(left, right)\r\n}\r\n\r\n/// Create a move commitment for showdown\r\n/// move = pedersen_hash([DOMAIN_MOVE, game_id, player_id, hand_hash])\r\npub fn hash_move_commitment(game_id: Field, player_id: Field, hand_hash: Field) -> Field {\r\n    hash_4(DOMAIN_MOVE, game_id, player_id, hand_hash)\r\n}\r\n\r\n// ============================================================\r\n// Tests\r\n// ============================================================\r\n\r\n#[test]\r\nfn test_hash_deterministic() {\r\n    // Verify same inputs always produce same output\r\n    let h1 = hash_2(1, 2);\r\n    let h2 = hash_2(1, 2);\r\n    assert(h1 == h2, \"Hash should be deterministic\");\r\n}\r\n\r\n#[test]\r\nfn test_hash_different_inputs() {\r\n    let h1 = hash_2(1, 2);\r\n    let h2 = hash_2(2, 1);\r\n    assert(h1 != h2, \"Different inputs should produce different hashes\");\r\n}\r\n\r\n#[test]\r\nfn test_domain_separation() {\r\n    // card_uid and card_commitment should differ even with same payload\r\n    let uid = hash_card_uid(14, 0); // Ace of Hearts\r\n    let commitment = hash_card_commitment(14, 0);\r\n    assert(uid != commitment, \"Domain separation should produce different hashes\");\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/unogame/teen-patti/3-Patti-zk/circuits/lib/src/hash.nr"},"57":{"source":"// Merkle tree utilities for ZK Teen Patti\r\n// Self-contained implementation - no external dependencies\r\n// Uses pedersen_hash for node hashing (compatible with Noir v1.0.0-beta.6)\r\n\r\nuse crate::types::{MERKLE_DEPTH, MerkleProof};\r\nuse crate::hash::hash_merkle_node;\r\n\r\n/// Compute the Merkle root from a leaf and its proof\r\n/// Walks up the tree using sibling hashes and direction bits\r\n///\r\n/// Parameters:\r\n/// - leaf: The leaf value (card commitment)\r\n/// - proof: MerkleProof containing sibling hashes and direction bits\r\n///\r\n/// Returns: The computed Merkle root\r\npub fn compute_merkle_root(leaf: Field, proof: MerkleProof) -> Field {\r\n    let mut current = leaf;\r\n\r\n    for i in 0..MERKLE_DEPTH {\r\n        let sibling = proof.path[i];\r\n        let is_right = proof.indices[i];\r\n\r\n        // If is_right == 1, current node is the right child\r\n        // So sibling is on the left: hash(sibling, current)\r\n        // If is_right == 0, current node is the left child\r\n        // So sibling is on the right: hash(current, sibling)\r\n        if is_right == 1 {\r\n            current = hash_merkle_node(sibling, current);\r\n        } else {\r\n            current = hash_merkle_node(current, sibling);\r\n        }\r\n    }\r\n\r\n    current\r\n}\r\n\r\n/// Assert that a leaf is included in a Merkle tree with the given root\r\npub fn assert_merkle_proof(leaf: Field, proof: MerkleProof, expected_root: Field) {\r\n    let computed_root = compute_merkle_root(leaf, proof);\r\n    assert(computed_root == expected_root, \"Invalid Merkle proof: root mismatch\");\r\n}\r\n\r\n/// Verify a Merkle proof (returns bool instead of asserting)\r\npub fn verify_merkle_proof(leaf: Field, proof: MerkleProof, expected_root: Field) -> bool {\r\n    let computed_root = compute_merkle_root(leaf, proof);\r\n    computed_root == expected_root\r\n}\r\n\r\n// ============================================================\r\n// Tests\r\n// ============================================================\r\n\r\n#[test]\r\nfn test_merkle_proof_simple() {\r\n    // Build a tiny tree: 2 leaves at depth 1\r\n    // For a full depth-6 tree, the remaining 5 levels use zero siblings\r\n    let leaf_a: Field = 100;\r\n    let leaf_b: Field = 200;\r\n\r\n    // Root = hash(leaf_a, leaf_b)\r\n    let root = hash_merkle_node(leaf_a, leaf_b);\r\n\r\n    // Proof for leaf_a (left child at level 0):\r\n    // index[0] = 0 (left), sibling[0] = leaf_b\r\n    // All higher levels use zero padding (hash with 0)\r\n    let mut path: [Field; 6] = [0; 6];\r\n    let mut indices: [u1; 6] = [0; 6];\r\n    path[0] = leaf_b;\r\n    // indices[0] = 0 (left child)\r\n\r\n    // Compute the full root by walking up with zero siblings\r\n    let mut expected_root = root;\r\n    for _i in 1..6 {\r\n        expected_root = hash_merkle_node(expected_root, 0);\r\n    }\r\n\r\n    let proof = MerkleProof { path, indices };\r\n    assert_merkle_proof(leaf_a, proof, expected_root);\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/unogame/teen-patti/3-Patti-zk/circuits/lib/src/merkle.nr"},"60":{"source":"// Input validation utilities for ZK Teen Patti\r\n\r\nuse crate::types::DECK_SIZE;\r\nuse crate::constants::{RANK_TWO, RANK_ACE, SUIT_SPADES};\r\n\r\n/// Assert that all positions in the array are unique\r\n/// Uses forward-only comparison: O(N*(N-1)/2)\r\npub fn assert_unique_positions<let N: u32>(positions: [u32; N]) {\r\n    for i in 0..N {\r\n        for j in (i + 1)..N {\r\n            assert(positions[i] != positions[j], \"Duplicate position found\");\r\n        }\r\n    }\r\n}\r\n\r\n/// Assert that all field values are unique\r\npub fn assert_unique_fields<let N: u32>(values: [Field; N]) {\r\n    for i in 0..N {\r\n        for j in (i + 1)..N {\r\n            assert(values[i] != values[j], \"Duplicate field value found\");\r\n        }\r\n    }\r\n}\r\n\r\n/// Assert that a position is within valid deck range (0 to DECK_SIZE-1)\r\npub fn assert_valid_position(position: u32) {\r\n    assert(position < DECK_SIZE, \"Position out of range (must be < 52)\");\r\n}\r\n\r\n/// Assert that a rank value is valid (2-14)\r\npub fn assert_valid_rank(rank: u8) {\r\n    assert(rank >= RANK_TWO, \"Rank must be >= 2\");\r\n    assert(rank <= RANK_ACE, \"Rank must be <= 14\");\r\n}\r\n\r\n/// Assert that a suit value is valid (0-3)\r\npub fn assert_valid_suit(suit: u8) {\r\n    assert(suit <= SUIT_SPADES, \"Suit must be <= 3\");\r\n}\r\n\r\n/// Validate a complete card (rank + suit)\r\npub fn assert_valid_card_inputs(rank: u8, suit: u8) {\r\n    assert_valid_rank(rank);\r\n    assert_valid_suit(suit);\r\n}\r\n\r\n// ============================================================\r\n// Tests\r\n// ============================================================\r\n\r\n#[test]\r\nfn test_unique_positions() {\r\n    let positions: [u32; 3] = [5, 10, 20];\r\n    assert_unique_positions(positions);\r\n}\r\n\r\n#[test(should_fail)]\r\nfn test_duplicate_positions_fail() {\r\n    let positions: [u32; 3] = [5, 10, 5];\r\n    assert_unique_positions(positions);\r\n}\r\n\r\n#[test]\r\nfn test_unique_fields() {\r\n    let values: [Field; 3] = [100, 200, 300];\r\n    assert_unique_fields(values);\r\n}\r\n\r\n#[test]\r\nfn test_valid_position() {\r\n    assert_valid_position(0);\r\n    assert_valid_position(51);\r\n}\r\n\r\n#[test(should_fail)]\r\nfn test_invalid_position() {\r\n    assert_valid_position(52);\r\n}\r\n\r\n#[test]\r\nfn test_valid_card_inputs() {\r\n    assert_valid_card_inputs(2, 0);   // 2 of Hearts\r\n    assert_valid_card_inputs(14, 3);  // Ace of Spades\r\n}\r\n\r\n#[test(should_fail)]\r\nfn test_invalid_rank_low() {\r\n    assert_valid_card_inputs(1, 0); // Rank 1 is invalid\r\n}\r\n\r\n#[test(should_fail)]\r\nfn test_invalid_rank_high() {\r\n    assert_valid_card_inputs(15, 0); // Rank 15 is invalid\r\n}\r\n\r\n#[test(should_fail)]\r\nfn test_invalid_suit() {\r\n    assert_valid_card_inputs(2, 4); // Suit 4 is invalid\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/unogame/teen-patti/3-Patti-zk/circuits/lib/src/validation.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_integer_quotient","directive_invert"]}