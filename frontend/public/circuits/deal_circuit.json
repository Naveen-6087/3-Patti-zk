{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"1179980854862454098","abi":{"parameters":[{"name":"player_id","type":{"kind":"field"},"visibility":"public"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"positions","type":{"kind":"array","length":3,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"},{"name":"card_uids","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"nonces","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_paths","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"zk_teen_patti::types::MerkleProof","fields":[{"name":"path","type":{"kind":"array","length":6,"type":{"kind":"field"}}},{"name":"indices","type":{"kind":"array","length":6,"type":{"kind":"integer","sign":"unsigned","width":1}}}]}},"visibility":"private"}],"return_type":null,"error_types":{"1657225594719303592":{"error_kind":"string","string":"Invalid Merkle proof: root mismatch"},"5985797412443528821":{"error_kind":"string","string":"Position out of range (must be < 52)"},"10908087124093645364":{"error_kind":"string","string":"Duplicate position found"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"pZnNbuM6DIXfxessREqiqL7KYFCkbWYQIEiLTDvARdF3v/rhcZOFBY+zKWnVOhK/6NBO+zm9HJ4+fj8ez79e/0wPPz6np8vxdDr+fjy9Pu/fj6/nMvo5ufqDZHrg3USpB50efAl5egi7icsd4etrN2Ha4/vlcKizrnSK+tv+cji/Tw/nj9NpN/3dnz7aTX/e9ucW3/eX8lu3mw7nlxKL4K/j6VCzr933bLc8VR3bZGWZp1O6mU/L8yUEmy/Rb5mvhPmqm+aj+OQW1x/UT6zeBMiXaVCItwTjsoJXEPQ5zPNl/fysNj+Q2zJ/Xn8wf0QguAgCIbglAnlwhqLgDCXZsgOJCTsQyUs7GCokmhXUbVII8VuBlhTIL0uUA4ijeI3R3wqEwR58mjkE/j5LMd5KDA6D0GwnHxcFZLAHZRiKNF45Mt9KpGUJ9vN5YK9+UUIHZ1oC6vCiYZNEEnwcXh1tk5jP5XaJkNdIjHBKQiGc2N8vIUsSI3vofLDo+kHxDwZLKc8Ky22GR2czfJ/NEPlb4rbb84BEYp09SpsEBEciXR3tfxAgp3AHEbslCT/sVTJzkJSXbO4Hj80wP3aj40UBvrtPeH93n/Dh7j4xlFjXJ8YSq/rEWGJVnxjiDDMLDnGbhHi8S3B5Hm6TWNWt1kssdquhyWj+UIlyWjJZ8HebLIQ7TRbi3SYLcvepGEqs+0jXS8gmiXXdIrq7u8VQYl23GEus6hZjiVXdYvwslfkxFLLcOORnudo/Hy+332mZyvt9+ebKPfgeQg+xB+kh1cdciWox9+idRbLIFr3FYDFaFIum503PV70CIBQ9Lg0rkF2zXft6Rkoser7YK8TKqUSx62TXWr8zlVi/k5fr6PoRjNTvi9zvi96ug12bXhSLqetE7Y0t5h6l6MUyLkUvlj4hbNFbDH1diX1dsf2J7U/UrnO/Ts4iWeS+bvJ9vRQsxr5ukr5OShbVotWrVq9avWr1qtWrVq9avWr1qtWrVq9avdnqzVZvtnqz1Zut3mz1Zqs3W73Z6s1WLzmHhJBYyeSsZnIBiVVNzsoml5AoEqucyEonstrLu5gtQR4jASMRiSAxAkSGgMgYEBsEYqNAzEg8EgNBbCSoOifWRZt3ck20H2ZiO+3k7bhT9U8931QN1LZaHdQ25gNGsOdqorbV6qK2aLVRW7T6qN0cwDmARgCNAOUAGtVNTbDZqW6j+aklarVXR7VKq6V6AhrVVG0b1VVtGxF7hq8oCkYSRhQJzkY1V9tGdVdbvdqrJ962UQ3WFq0O6wnOhoCGgIaABmxGCTQSaCTQSKCRQCOBRgKNBBoJNBQ0FDQUNBQ0FDTgOlLQUNBQ0FDQyKCRQSODRgaNDBoZNDJoZNDIoJGNBsOD7AgjjBGPJCAxGuyMBruExGiwMxpMDgkhMRpMRoOrB6svuHqwuoDbX1W5JgkjipHcfcHVg22rbH2DmTGCPTcP1v00D7YRsUWrB/vNiptBw4OGh7IHjerBJuitI3HzYEvEavfWkdgrEtCoHmzbqB5s2wjYMzzIeKAxnmgcBElCYg81DtaRuHqwJ2TbiNaROHokAQloRNCIoAEPcgQNAQ0BDQENAQ0BDQENAQ0BDQENAY0EGgk0EmjAg5xAI4FGAo0EGgk0EmgoaChoKGgoaChoKGgoaChowIOsoJFBI4NGBo0MGhk0Mmhk0MigkUEjGw3vjIZ3RsNXD8b6Be3v/nLcP50O9RWtvsR9nJ/xxlYu3/97w2/wf4q3y+vz4eXjcqhvd1f/rCg/f3DYcf75Vd8A/wc=","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"// Deal Verification Circuit for ZK Teen Patti\r\n// Proves that a player received 3 valid cards from the deck\r\n// without revealing which cards were dealt\r\n//\r\n// Public inputs: 2 (player_id, merkle_root)\r\n// Private inputs: positions[3], card_uids[3], nonces[3], merkle_paths[3]\r\n//\r\n// The circuit verifies:\r\n// 1. Card positions are unique and within range (0-51)\r\n// 2. Each card commitment (hash of uid + nonce) exists in the Merkle tree\r\n// 3. The Merkle tree root matches the public commitment\r\n\r\nuse dep::zk_teen_patti::types::MerkleProof;\r\nuse dep::zk_teen_patti::encoding::commit_card;\r\nuse dep::zk_teen_patti::merkle::assert_merkle_proof;\r\nuse dep::zk_teen_patti::validation::{assert_unique_positions, assert_valid_position};\r\n\r\nfn main(\r\n    // ========== Public inputs (2 total, well within 32 limit) ==========\r\n    player_id: pub Field,\r\n    merkle_root: pub Field,\r\n\r\n    // ========== Private witnesses ==========\r\n    positions: [u32; 3],              // Deck positions of dealt cards\r\n    card_uids: [Field; 3],           // Card unique identifiers\r\n    nonces: [Field; 3],              // Random nonces for commitments\r\n    merkle_paths: [MerkleProof; 3],  // Merkle inclusion proofs\r\n) {\r\n    // 1. Verify all positions are unique (no duplicate cards dealt)\r\n    assert_unique_positions(positions);\r\n\r\n    // 2. Verify positions are in valid range (0-51)\r\n    for i in 0..3 {\r\n        assert_valid_position(positions[i]);\r\n    }\r\n\r\n    // 3. Verify each card's commitment is in the Merkle tree\r\n    for i in 0..3 {\r\n        // Compute commitment: pedersen_hash([DOMAIN_CARD_COMMITMENT, uid, nonce])\r\n        let commitment = commit_card(card_uids[i], nonces[i]);\r\n\r\n        // Verify the commitment is in the deck Merkle tree at the claimed position\r\n        assert_merkle_proof(commitment, merkle_paths[i], merkle_root);\r\n    }\r\n\r\n    // The player_id is a public input that associates this proof with a specific player\r\n    // It doesn't need in-circuit verification beyond being declared as public\r\n    let _ = player_id;\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/unogame/teen-patti/3-Patti-zk/circuits/deal/src/main.nr"},"53":{"source":"// Card encoding utilities for ZK Teen Patti\r\n\r\nuse crate::hash::hash_card_commitment;\r\nuse crate::card_uids::get_card_uid;\r\nuse crate::constants::{RANK_TWO, RANK_ACE, SUIT_SPADES};\r\n\r\n/// Verify that a card UID matches the expected rank and suit\r\n/// Computes the UID from (rank, suit) and asserts it equals the provided uid\r\npub fn verify_card_uid(rank: u8, suit: u8, expected_uid: Field) {\r\n    let computed_uid = get_card_uid(rank, suit);\r\n    assert(computed_uid == expected_uid, \"Card UID mismatch\");\r\n}\r\n\r\n/// Create a card commitment (Merkle tree leaf)\r\n/// commitment = pedersen_hash([DOMAIN_CARD_COMMITMENT, card_uid, nonce])\r\npub fn commit_card(card_uid: Field, nonce: Field) -> Field {\r\n    hash_card_commitment(card_uid, nonce)\r\n}\r\n\r\n/// Validate that rank and suit values are in valid ranges\r\npub fn assert_valid_card(rank: u8, suit: u8) {\r\n    assert(rank >= RANK_TWO, \"Rank must be >= 2\");\r\n    assert(rank <= RANK_ACE, \"Rank must be <= 14 (Ace)\");\r\n    assert(suit <= SUIT_SPADES, \"Suit must be <= 3\");\r\n}\r\n\r\n// ============================================================\r\n// Tests\r\n// ============================================================\r\n\r\n#[test]\r\nfn test_commit_card() {\r\n    let uid = get_card_uid(14, 0); // Ace of Hearts\r\n    let nonce: Field = 12345;\r\n    let c1 = commit_card(uid, nonce);\r\n    let c2 = commit_card(uid, nonce);\r\n    assert(c1 == c2, \"Same inputs should produce same commitment\");\r\n}\r\n\r\n#[test]\r\nfn test_commit_different_nonces() {\r\n    let uid = get_card_uid(14, 0);\r\n    let c1 = commit_card(uid, 111);\r\n    let c2 = commit_card(uid, 222);\r\n    assert(c1 != c2, \"Different nonces should produce different commitments\");\r\n}\r\n\r\n#[test]\r\nfn test_verify_card_uid() {\r\n    let uid = get_card_uid(10, 2); // Ten of Clubs\r\n    verify_card_uid(10, 2, uid);   // Should not panic\r\n}\r\n\r\n#[test]\r\nfn test_assert_valid_card() {\r\n    assert_valid_card(2, 0);   // 2 of Hearts\r\n    assert_valid_card(14, 3);  // Ace of Spades\r\n    assert_valid_card(10, 2);  // Ten of Clubs\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/unogame/teen-patti/3-Patti-zk/circuits/lib/src/encoding.nr"},"55":{"source":"// Hashing utilities for ZK Teen Patti\r\n// Uses std::hash::pedersen_hash - guaranteed available in Noir v1.0.0-beta.6\r\n// Pedersen hash is a black-box function backed by Barretenberg, so it is\r\n// consistent across the Noir circuit AND the bb.js/Barretenberg JS/WASM API.\r\n\r\nuse std::hash::pedersen_hash;\r\n\r\nuse crate::constants::{DOMAIN_CARD_UID, DOMAIN_CARD_COMMITMENT, DOMAIN_MOVE};\r\n\r\n/// Hash 2 field elements using Pedersen\r\npub fn hash_2(a: Field, b: Field) -> Field {\r\n    pedersen_hash([a, b])\r\n}\r\n\r\n/// Hash 3 field elements using Pedersen\r\npub fn hash_3(a: Field, b: Field, c: Field) -> Field {\r\n    pedersen_hash([a, b, c])\r\n}\r\n\r\n/// Hash 4 field elements using Pedersen\r\npub fn hash_4(a: Field, b: Field, c: Field, d: Field) -> Field {\r\n    pedersen_hash([a, b, c, d])\r\n}\r\n\r\n/// Compute a card's unique identifier\r\n/// card_uid = pedersen_hash([DOMAIN_CARD_UID, rank, suit])\r\n///\r\n/// NOTE: For performance, use the precomputed lookup table in card_uids.nr\r\n/// instead of calling this at runtime. This function is for testing/validation.\r\npub fn hash_card_uid(rank: u8, suit: u8) -> Field {\r\n    hash_3(DOMAIN_CARD_UID, rank as Field, suit as Field)\r\n}\r\n\r\n/// Create a card commitment (used as Merkle tree leaf)\r\n/// commitment = pedersen_hash([DOMAIN_CARD_COMMITMENT, card_uid, nonce])\r\npub fn hash_card_commitment(card_uid: Field, nonce: Field) -> Field {\r\n    hash_3(DOMAIN_CARD_COMMITMENT, card_uid, nonce)\r\n}\r\n\r\n/// Hash two Merkle tree children into a parent node\r\n/// Using raw pedersen_hash (no domain separation) for simplicity\r\n/// node = pedersen_hash([left, right])\r\npub fn hash_merkle_node(left: Field, right: Field) -> Field {\r\n    hash_2(left, right)\r\n}\r\n\r\n/// Create a move commitment for showdown\r\n/// move = pedersen_hash([DOMAIN_MOVE, game_id, player_id, hand_hash])\r\npub fn hash_move_commitment(game_id: Field, player_id: Field, hand_hash: Field) -> Field {\r\n    hash_4(DOMAIN_MOVE, game_id, player_id, hand_hash)\r\n}\r\n\r\n// ============================================================\r\n// Tests\r\n// ============================================================\r\n\r\n#[test]\r\nfn test_hash_deterministic() {\r\n    // Verify same inputs always produce same output\r\n    let h1 = hash_2(1, 2);\r\n    let h2 = hash_2(1, 2);\r\n    assert(h1 == h2, \"Hash should be deterministic\");\r\n}\r\n\r\n#[test]\r\nfn test_hash_different_inputs() {\r\n    let h1 = hash_2(1, 2);\r\n    let h2 = hash_2(2, 1);\r\n    assert(h1 != h2, \"Different inputs should produce different hashes\");\r\n}\r\n\r\n#[test]\r\nfn test_domain_separation() {\r\n    // card_uid and card_commitment should differ even with same payload\r\n    let uid = hash_card_uid(14, 0); // Ace of Hearts\r\n    let commitment = hash_card_commitment(14, 0);\r\n    assert(uid != commitment, \"Domain separation should produce different hashes\");\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/unogame/teen-patti/3-Patti-zk/circuits/lib/src/hash.nr"},"57":{"source":"// Merkle tree utilities for ZK Teen Patti\r\n// Self-contained implementation - no external dependencies\r\n// Uses pedersen_hash for node hashing (compatible with Noir v1.0.0-beta.6)\r\n\r\nuse crate::types::{MERKLE_DEPTH, MerkleProof};\r\nuse crate::hash::hash_merkle_node;\r\n\r\n/// Compute the Merkle root from a leaf and its proof\r\n/// Walks up the tree using sibling hashes and direction bits\r\n///\r\n/// Parameters:\r\n/// - leaf: The leaf value (card commitment)\r\n/// - proof: MerkleProof containing sibling hashes and direction bits\r\n///\r\n/// Returns: The computed Merkle root\r\npub fn compute_merkle_root(leaf: Field, proof: MerkleProof) -> Field {\r\n    let mut current = leaf;\r\n\r\n    for i in 0..MERKLE_DEPTH {\r\n        let sibling = proof.path[i];\r\n        let is_right = proof.indices[i];\r\n\r\n        // If is_right == 1, current node is the right child\r\n        // So sibling is on the left: hash(sibling, current)\r\n        // If is_right == 0, current node is the left child\r\n        // So sibling is on the right: hash(current, sibling)\r\n        if is_right == 1 {\r\n            current = hash_merkle_node(sibling, current);\r\n        } else {\r\n            current = hash_merkle_node(current, sibling);\r\n        }\r\n    }\r\n\r\n    current\r\n}\r\n\r\n/// Assert that a leaf is included in a Merkle tree with the given root\r\npub fn assert_merkle_proof(leaf: Field, proof: MerkleProof, expected_root: Field) {\r\n    let computed_root = compute_merkle_root(leaf, proof);\r\n    assert(computed_root == expected_root, \"Invalid Merkle proof: root mismatch\");\r\n}\r\n\r\n/// Verify a Merkle proof (returns bool instead of asserting)\r\npub fn verify_merkle_proof(leaf: Field, proof: MerkleProof, expected_root: Field) -> bool {\r\n    let computed_root = compute_merkle_root(leaf, proof);\r\n    computed_root == expected_root\r\n}\r\n\r\n// ============================================================\r\n// Tests\r\n// ============================================================\r\n\r\n#[test]\r\nfn test_merkle_proof_simple() {\r\n    // Build a tiny tree: 2 leaves at depth 1\r\n    // For a full depth-6 tree, the remaining 5 levels use zero siblings\r\n    let leaf_a: Field = 100;\r\n    let leaf_b: Field = 200;\r\n\r\n    // Root = hash(leaf_a, leaf_b)\r\n    let root = hash_merkle_node(leaf_a, leaf_b);\r\n\r\n    // Proof for leaf_a (left child at level 0):\r\n    // index[0] = 0 (left), sibling[0] = leaf_b\r\n    // All higher levels use zero padding (hash with 0)\r\n    let mut path: [Field; 6] = [0; 6];\r\n    let mut indices: [u1; 6] = [0; 6];\r\n    path[0] = leaf_b;\r\n    // indices[0] = 0 (left child)\r\n\r\n    // Compute the full root by walking up with zero siblings\r\n    let mut expected_root = root;\r\n    for _i in 1..6 {\r\n        expected_root = hash_merkle_node(expected_root, 0);\r\n    }\r\n\r\n    let proof = MerkleProof { path, indices };\r\n    assert_merkle_proof(leaf_a, proof, expected_root);\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/unogame/teen-patti/3-Patti-zk/circuits/lib/src/merkle.nr"},"60":{"source":"// Input validation utilities for ZK Teen Patti\r\n\r\nuse crate::types::DECK_SIZE;\r\nuse crate::constants::{RANK_TWO, RANK_ACE, SUIT_SPADES};\r\n\r\n/// Assert that all positions in the array are unique\r\n/// Uses forward-only comparison: O(N*(N-1)/2)\r\npub fn assert_unique_positions<let N: u32>(positions: [u32; N]) {\r\n    for i in 0..N {\r\n        for j in (i + 1)..N {\r\n            assert(positions[i] != positions[j], \"Duplicate position found\");\r\n        }\r\n    }\r\n}\r\n\r\n/// Assert that all field values are unique\r\npub fn assert_unique_fields<let N: u32>(values: [Field; N]) {\r\n    for i in 0..N {\r\n        for j in (i + 1)..N {\r\n            assert(values[i] != values[j], \"Duplicate field value found\");\r\n        }\r\n    }\r\n}\r\n\r\n/// Assert that a position is within valid deck range (0 to DECK_SIZE-1)\r\npub fn assert_valid_position(position: u32) {\r\n    assert(position < DECK_SIZE, \"Position out of range (must be < 52)\");\r\n}\r\n\r\n/// Assert that a rank value is valid (2-14)\r\npub fn assert_valid_rank(rank: u8) {\r\n    assert(rank >= RANK_TWO, \"Rank must be >= 2\");\r\n    assert(rank <= RANK_ACE, \"Rank must be <= 14\");\r\n}\r\n\r\n/// Assert that a suit value is valid (0-3)\r\npub fn assert_valid_suit(suit: u8) {\r\n    assert(suit <= SUIT_SPADES, \"Suit must be <= 3\");\r\n}\r\n\r\n/// Validate a complete card (rank + suit)\r\npub fn assert_valid_card_inputs(rank: u8, suit: u8) {\r\n    assert_valid_rank(rank);\r\n    assert_valid_suit(suit);\r\n}\r\n\r\n// ============================================================\r\n// Tests\r\n// ============================================================\r\n\r\n#[test]\r\nfn test_unique_positions() {\r\n    let positions: [u32; 3] = [5, 10, 20];\r\n    assert_unique_positions(positions);\r\n}\r\n\r\n#[test(should_fail)]\r\nfn test_duplicate_positions_fail() {\r\n    let positions: [u32; 3] = [5, 10, 5];\r\n    assert_unique_positions(positions);\r\n}\r\n\r\n#[test]\r\nfn test_unique_fields() {\r\n    let values: [Field; 3] = [100, 200, 300];\r\n    assert_unique_fields(values);\r\n}\r\n\r\n#[test]\r\nfn test_valid_position() {\r\n    assert_valid_position(0);\r\n    assert_valid_position(51);\r\n}\r\n\r\n#[test(should_fail)]\r\nfn test_invalid_position() {\r\n    assert_valid_position(52);\r\n}\r\n\r\n#[test]\r\nfn test_valid_card_inputs() {\r\n    assert_valid_card_inputs(2, 0);   // 2 of Hearts\r\n    assert_valid_card_inputs(14, 3);  // Ace of Spades\r\n}\r\n\r\n#[test(should_fail)]\r\nfn test_invalid_rank_low() {\r\n    assert_valid_card_inputs(1, 0); // Rank 1 is invalid\r\n}\r\n\r\n#[test(should_fail)]\r\nfn test_invalid_rank_high() {\r\n    assert_valid_card_inputs(15, 0); // Rank 15 is invalid\r\n}\r\n\r\n#[test(should_fail)]\r\nfn test_invalid_suit() {\r\n    assert_valid_card_inputs(2, 4); // Suit 4 is invalid\r\n}\r\n","path":"/mnt/c/Users/hemav/OneDrive/Desktop/unogame/teen-patti/3-Patti-zk/circuits/lib/src/validation.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_invert","directive_integer_quotient"]}